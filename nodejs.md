## ====================== Node JS 学习笔记 =======================
# 准备工作
    - 命令行窗口 (cmd) : window+R 打开命令窗口，输入 cmd 然后回车， 得到小黑屏； （CMD, 小黑屏，终端， Shell)
    - 常用指令：
       dir  列出当前目录下的所有文件；
       ls  列出当前目录下的所有文件；
       cd   目录名： 进入到指定目录下
       md 或者 mkdir 目录名： 创建一个目录
       rd 或者 rm 目录名： 删除一个目录
    - 目录： 
       . 表示当前目录 
       .. 表示上一级目录
    - 环境变量： （也就是windows系统中的变量）path
        1. 创建了环境变量path后，可以在终端直接打开Path目录下的文件
        2. 当命令行窗口，打开一个文件或者调用一个程序时候，系统会首先在当前目录下寻找文件或程序，如果找到，则直接打开，
           如果没有找到，则依次到环境变量path的路径中寻找，直到找到为止，如果找不到则报错。 相当于作用域链；
        3. 所以我们可以将一些经常访问的程序和文件的路径添加到path中，这样可以在任意位置访问文件和程序。
        4. 如果想切换 从C盘 到 D 盘， 可以直接： d:
# node 基础： 进程和线程
    - 进程
        1. 进程负责为程序的运行提供必备的环境
        2. 进程相当于工厂中的车间
    -线程： 
        1. 线程是计算机中最小的计算单位，线程负责执行保存到进程中的程序
        2. 线程相当于工厂中的工人
    - 单线程和多线程
        1.  一个人还是多个人干活
    - 传统服务器都是多线程的
        1.每进来一个请求，就创建一个线程去处理这个请求
    - Node 的服务器是单线程的
        1. Node 处理请求时是单线程的，但是在后台拥有一个I/O线程池
        2. 可以通过增加服务器数量改进
# node 简介
    - Node.js 简介
        1. Node.js 是一个能够在服务器端运行JS的开放源代码，跨平台JS运行环境
        2. Node 采用Google开发的V8引擎运行JS代码，使用事件驱动，非阻塞和异步I/O模型等技术来提高性能，可以优化应用程序的传输量和规模
        3. Node 大部分基本模块都用JS编写。 在Node出现之前，JS通常作为客户端程序设计语言使用，所以JS写出的程序常在用户的浏览器上运行
        4. 目前，Node 已经被IBM,Microsoft,Yahoo!,Walmart 等企业采用
        5. Ryan Dahl 瑞恩*达尔 Node.JS 之父； 数学博士出身；  
    - 全栈分为： 客户端（请求和响应）到服务器端（I/O)到数据库 （I/O 就是 input/output 数据的读取和输出） I/O 有时候会阻塞我们的多线程请求，一般程序的性能最终都卡在I/O这块
    - V8 引擎出世，结合JS 单线程特点， Ray在 2009 你开始着手编写 node.JS,用js去写一个web服务器，得到性能优化；一开始叫 web.js 后来改名 node.js （搂不住了），成了生态系统
    - Node 的用途： Web服务API， 比如 REST, 实时多人游戏， 后端的Web服务，例如跨域，服务器端的请求，基于Web的应用，多客户端的通信，如即时通信
    - Node 运行 js 文件就是在终端进入到文件目录下，输入： node 文件名.js
# 模块化
    - 模块化就是将一个大程序拆分成多个小模块，实现代码复用，便于维护；高内聚，低耦合。
    - ECMAScript 标准缺少模块系统，标准库较少，没有标准接口，缺乏管理系统；
    - CommonJS规范主要弥补当前JS没有标准的缺陷， 主要包含： 模块引用，模块定义，模块标识
    - 在Node 中，一个JS文件就是一个模块；
    - 在Node中，通过 require() 函数方法来引入模块，参数是模块的路径,node 将会自动根据该路径引入外部模块，如果使用相对路径，必须以 ./ 或者 ../ 开头
    - 使用 require() 引入模块以后，该函数会返回一个对象，这个对象代表的是引入的模块；
       const m = require('./1.module.js') // 此处 m 就是一个对象，这个对象就是 1.module.js这个文件
    - 在node中，每个js文件中的js代码，都是独立运行在一个函数中，不是全局里。相当于这个文件是在一个自调用的函数里执行的。在全局里是看不到js单个文件（模块）里定义的变量的。
    - 有一些东西如果想暴露，在module里向外暴露属性或者方法可以用语法： exports 来向外部暴露属性或者变量或者方法：可以把export 想象成一个对象，然后里面含有需要暴露的元素：
        exports.x = '我是module2里的变量x' // 这样就把module2里的变量x 暴露出来，在别的module里也可以读取到了。
    - 我们使用require() 引入外部模块时候，就是使用的模块标识，我们可以通过模块标识找到需要的模块。路径就是一种标识
    - 模块分为两大类： 
        1. 核心模块
            -- 由node引擎提供的模块
            -- 核心模块的引用标识就是模块的名字 比如： const fs = require('fs') // 这样就引入了node引擎提供的原装fs模块；
        2. 文件模块
            -- 由用户自己创建的模块
            -- 文件模块的标识就是文件的路径，可以是绝对或者相对的。相对路径用./或者../开头
    - 在 node 中有一个全局对象，我们叫global,类似于网页中的 window， 在全局中创建的变量都会作为global的属性保存，在全局中创建的方法，都会在global的属性方法里保存。定义变量时候如果不用 var 直接 a=10 ， 那么此时a就默认是全局变量；
    - 当 node在执行模块中的代码时，会首先在代码的最顶部添加如下代码：function (exports, require, module, __filename, __dirname) {
       在代码的最下面，添加如下： } ； 
       就是node在执行时候，把模块用函数包装起来了。所以里面的变量都是局部变量；
    - 实际上模块中的代码都是包装在一个函数中执行的，并且在函数执行时，同时传递进来5个实参： 
            exports : 该对象用来将内部变量或者函数暴露给外部
            require ： 该函数方法用来引入外部的模块
            module ：  代表的是当前模块自身本身， 其中 exports 其实就是module的属性，既可以使用exports 导出，也可以使用 module.exports导出
            __filename ： 是当前模块的完整路径；
            __dirname ： 是当前文件所在的文件夹完整路径；
    - exports 和 module.exports 本质上是一个对象，通过export 只能通过 exports.变量名形式暴露， module.export 可以通过 module.exports ={} 的方式统一暴露
        
# Package npm包
    - CommonJS 的包规范允许我们将一组相关的模块组合到一起，形成一组完整的工具
    - CommonJS 的包规范由包结构和包描述文件两个部分组成
        1. 包结构： 用于组织包中的各种文件
        2. 包描述文件： 用于描述包的相关信息，以供外部读取分析
    - 包实际就是一个压缩文件，解压以后还原为目录。符合规范的目录，应该包含：（其中1.package.json 是必须的）
        1. package.json : 是描述文件
        2. bin 可执行二进制文件
        3. lib js代码
        4. doc 文档
        5. test 单元测试
    - 
